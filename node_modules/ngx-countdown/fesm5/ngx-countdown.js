import { __decorate, __metadata, __param, __assign } from 'tslib';
import { NgZone, Injectable, Inject, LOCALE_ID, ɵɵdefineInjectable, ɵɵinject, EventEmitter, ChangeDetectorRef, Input, TemplateRef, Output, Component, ViewEncapsulation, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { formatDate, CommonModule } from '@angular/common';

var CountdownStatus;
(function (CountdownStatus) {
    CountdownStatus[CountdownStatus["ing"] = 0] = "ing";
    CountdownStatus[CountdownStatus["pause"] = 1] = "pause";
    CountdownStatus[CountdownStatus["stop"] = 2] = "stop";
    CountdownStatus[CountdownStatus["done"] = 3] = "done";
})(CountdownStatus || (CountdownStatus = {}));

var CountdownTimer = /** @class */ (function () {
    function CountdownTimer(ngZone) {
        this.ngZone = ngZone;
        this.fns = [];
        this.commands = [];
        this.ing = false;
    }
    CountdownTimer.prototype.start = function () {
        var _this = this;
        if (this.ing === true)
            return;
        this.ing = true;
        this.nextTime = +new Date();
        this.ngZone.runOutsideAngular(function () {
            _this.process();
        });
    };
    CountdownTimer.prototype.process = function () {
        var _this = this;
        while (this.commands.length) {
            this.commands.shift()();
        }
        var diff = +new Date() - this.nextTime;
        var count = 1 + Math.floor(diff / 100);
        diff = 100 - (diff % 100);
        this.nextTime += 100 * count;
        for (var i = 0, len = this.fns.length; i < len; i += 2) {
            var frequency = this.fns[i + 1];
            // 100/s
            if (0 === frequency) {
                this.fns[i](count);
                // 1000/s
            }
            else {
                // 先把末位至0，再每次加2
                frequency += 2 * count - 1;
                var step = Math.floor(frequency / 20);
                if (step > 0) {
                    this.fns[i](step);
                }
                // 把末位还原成1
                this.fns[i + 1] = (frequency % 20) + 1;
            }
        }
        if (!this.ing)
            return;
        setTimeout(function () { return _this.process(); }, diff);
    };
    CountdownTimer.prototype.add = function (fn, frequency) {
        var _this = this;
        this.commands.push(function () {
            _this.fns.push(fn);
            _this.fns.push(frequency === 1000 ? 1 : 0);
            _this.ing = true;
        });
        return this;
    };
    CountdownTimer.prototype.remove = function (fn) {
        var _this = this;
        this.commands.push(function () {
            var i = _this.fns.indexOf(fn);
            if (i !== -1) {
                _this.fns.splice(i, 2);
            }
            _this.ing = _this.fns.length > 0;
        });
        return this;
    };
    CountdownTimer.ctorParameters = function () { return [
        { type: NgZone }
    ]; };
    CountdownTimer = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [NgZone])
    ], CountdownTimer);
    return CountdownTimer;
}());

var CountdownGlobalConfig = /** @class */ (function () {
    function CountdownGlobalConfig(locale) {
        var _this = this;
        this.locale = locale;
        this.demand = false;
        this.leftTime = 0;
        this.format = 'HH:mm:ss';
        this.timezone = '+0000';
        this.formatDate = function (_a) {
            var date = _a.date, formatStr = _a.formatStr, timezone = _a.timezone;
            return formatDate(new Date(date), formatStr, _this.locale, timezone || _this.timezone || '+0000');
        };
    }
    CountdownGlobalConfig.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
    ]; };
    CountdownGlobalConfig.ɵprov = ɵɵdefineInjectable({ factory: function CountdownGlobalConfig_Factory() { return new CountdownGlobalConfig(ɵɵinject(LOCALE_ID)); }, token: CountdownGlobalConfig, providedIn: "root" });
    CountdownGlobalConfig = __decorate([
        Injectable({ providedIn: 'root' }),
        __param(0, Inject(LOCALE_ID)),
        __metadata("design:paramtypes", [String])
    ], CountdownGlobalConfig);
    return CountdownGlobalConfig;
}());

var CountdownComponent = /** @class */ (function () {
    function CountdownComponent(locale, timer, defCog, cdr, ngZone) {
        this.locale = locale;
        this.timer = timer;
        this.defCog = defCog;
        this.cdr = cdr;
        this.ngZone = ngZone;
        this.frequency = 1000;
        this._notify = {};
        this._left = 0;
        this.status = CountdownStatus.ing;
        this.isDestroy = false;
        this.i = {};
        this.event = new EventEmitter();
    }
    Object.defineProperty(CountdownComponent.prototype, "left", {
        get: function () {
            return this._left;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Start countdown, you must manually call when `demand: false`
     */
    CountdownComponent.prototype.begin = function () {
        this.status = CountdownStatus.ing;
        this.callEvent('start');
    };
    /**
     * Restart countdown
     */
    CountdownComponent.prototype.restart = function () {
        if (this.status !== CountdownStatus.stop) {
            this.destroy();
        }
        this.init();
        this.callEvent('restart');
    };
    /**
     * Stop countdown, must call `restart` when stopped, it's different from pause, unable to recover
     */
    CountdownComponent.prototype.stop = function () {
        if (this.status === CountdownStatus.stop) {
            return;
        }
        this.status = CountdownStatus.stop;
        this.destroy();
        this.callEvent('stop');
    };
    /**
     * Pause countdown, you can use `resume` to recover again
     */
    CountdownComponent.prototype.pause = function () {
        if (this.status === CountdownStatus.stop || this.status === CountdownStatus.pause)
            return;
        this.status = CountdownStatus.pause;
        this.callEvent('pause');
    };
    /**
     * Resume countdown
     */
    CountdownComponent.prototype.resume = function () {
        if (this.status === CountdownStatus.stop || this.status !== CountdownStatus.pause)
            return;
        this.status = CountdownStatus.ing;
        this.callEvent('resume');
    };
    CountdownComponent.prototype.callEvent = function (action) {
        this.event.emit({ action: action, left: this._left, status: this.status, text: this.i.text });
    };
    CountdownComponent.prototype.init = function () {
        var _this = this;
        var _a = this, locale = _a.locale, defCog = _a.defCog;
        var config = (this.config = __assign(__assign(__assign({}, new CountdownGlobalConfig(locale)), defCog), this.config));
        // tslint:disable-next-line: no-bitwise
        var frq = (this.frequency = ~config.format.indexOf('S') ? 100 : 1000);
        this.status = config.demand ? CountdownStatus.pause : CountdownStatus.ing;
        this.getLeft();
        // bind reflow to me
        var _reflow = this.reflow;
        this.reflow = function (count, force) {
            if (count === void 0) { count = 0; }
            if (force === void 0) { force = false; }
            return _reflow.apply(_this, [count, force]);
        };
        if (Array.isArray(config.notify)) {
            config.notify.forEach(function (time) {
                if (time < 1)
                    throw new Error("The notify config must be a positive integer.");
                time = time * 1000;
                time = time - (time % frq);
                _this._notify[time] = true;
            });
        }
        this.timer.add(this.reflow, frq).start();
        this.reflow(0, true);
    };
    CountdownComponent.prototype.destroy = function () {
        this.timer.remove(this.reflow);
        return this;
    };
    /**
     * 更新时钟
     */
    CountdownComponent.prototype.reflow = function (count, force) {
        var _this = this;
        if (count === void 0) { count = 0; }
        if (force === void 0) { force = false; }
        if (this.isDestroy)
            return;
        var _a = this, status = _a.status, config = _a.config, _notify = _a._notify;
        if (!force && status !== CountdownStatus.ing)
            return;
        var value = (this._left = this._left - this.frequency * count);
        this.i = {
            value: value,
            text: config.formatDate({ date: value, formatStr: config.format, timezone: config.timezone }),
        };
        if (typeof config.prettyText === 'function') {
            this.i.text = config.prettyText(this.i.text);
        }
        this.cdr.detectChanges();
        if (config.notify === 0 || _notify[value]) {
            this.ngZone.run(function () {
                _this.callEvent('notify');
            });
        }
        if (value < 1) {
            this.ngZone.run(function () {
                _this.status = CountdownStatus.done;
                _this.callEvent('done');
                _this.destroy();
            });
        }
    };
    /**
     * 获取倒计时剩余帧数
     */
    CountdownComponent.prototype.getLeft = function () {
        var _a = this, config = _a.config, frequency = _a.frequency;
        var left = config.leftTime * 1000;
        var end = config.stopTime;
        if (!left && end) {
            left = end - new Date().getTime();
        }
        this._left = left - (left % frequency);
    };
    CountdownComponent.prototype.ngOnInit = function () {
        this.init();
        if (!this.config.demand) {
            this.begin();
        }
    };
    CountdownComponent.prototype.ngOnDestroy = function () {
        this.isDestroy = true;
        this.destroy();
    };
    CountdownComponent.prototype.ngOnChanges = function (changes) {
        if (!changes.config.firstChange) {
            this.restart();
        }
    };
    CountdownComponent.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
        { type: CountdownTimer },
        { type: CountdownGlobalConfig },
        { type: ChangeDetectorRef },
        { type: NgZone }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CountdownComponent.prototype, "config", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], CountdownComponent.prototype, "render", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CountdownComponent.prototype, "event", void 0);
    CountdownComponent = __decorate([
        Component({
            selector: 'countdown',
            template: "\n    <ng-container *ngIf=\"!render\">\n      <span [innerHTML]=\"i.text\"></span>\n    </ng-container>\n    <ng-container *ngTemplateOutlet=\"render; context: { $implicit: i }\"></ng-container>\n  ",
            host: { '[class.count-down]': 'true' },
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush
        }),
        __param(0, Inject(LOCALE_ID)),
        __metadata("design:paramtypes", [String, CountdownTimer,
            CountdownGlobalConfig,
            ChangeDetectorRef,
            NgZone])
    ], CountdownComponent);
    return CountdownComponent;
}());

var CountdownModule = /** @class */ (function () {
    function CountdownModule() {
    }
    CountdownModule = __decorate([
        NgModule({
            imports: [CommonModule],
            providers: [CountdownTimer],
            declarations: [CountdownComponent],
            exports: [CountdownComponent],
        })
    ], CountdownModule);
    return CountdownModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { CountdownComponent, CountdownGlobalConfig, CountdownModule, CountdownStatus, CountdownTimer };
//# sourceMappingURL=ngx-countdown.js.map
